import numpy as np
import random
from robupy.auxiliary import get_worst_case_probs, get_worst_case_outcome
from robupy.auxiliary import criterion_full
from scipy.stats import multivariate_normal


from scipy.stats import entropy
from robupy.auxiliary import get_entropic_risk_measure
from functools import partial
from scipy.optimize import minimize_scalar
from robupy.tests.auxiliary import get_request
from robupy.auxiliary import get_multiplier_evaluation

from statsmodels.sandbox.distributions.extras import mvnormcdf
from scipy.stats import wishart

np.random.seed(54)
from robupy.sandbox import get_normal_probabilities


while True:


    seed = random.randrange(1, 10000000)
    np.random.seed(seed)
    print(seed)
    num_bin = np.random.randint(2, 5)
    num_dim = 4

    num_points = num_bin ** num_dim

    v = np.random.normal(size=num_points, scale=10)

    # We want to integrate the case where the probabilities are generated by the discretized
    # normal distribution.
    if np.random.choice([True, False]):
        q = np.random.uniform(low=0.01, size=num_points)
        q = q / np.sum(q)
    else:
        mean = np.random.normal(size=num_dim)
        cov = wishart.rvs(num_dim, np.identity(num_dim))
        q = get_normal_probabilities(num_bin, mean, cov)[0].flatten()

        # We need to remove all zero-probability events.
        is_nonzero = (q != 0)
        q, v = q[is_nonzero], v[is_nonzero]

    gamma = np.random.uniform()


    rslt_risk = get_entropic_risk_measure(v, q, gamma)
    rslt_mult = get_multiplier_evaluation(v, q, 1.0 / gamma)

    np.testing.assert_almost_equal(-rslt_risk, rslt_mult, decimal=4)
